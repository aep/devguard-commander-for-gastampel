/*
 * Devguard Open Hardware API
 *
 * Although devguard does offer direct end to end encrypted connections, some users may prefer a third party to establish a connection for them, as it is done by data hungry cloud corporations.  The Open Hardware API can be called with any standard https client by passing an secretkit in the headers, and a devguard hosted webservice will establish a device connection on behalf of the user.  We still do not collect any data, however due to the nature of webservices, interception by third parties is possible and the OHA service comes with no waranty whatsoever. 
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package server

import (
	"net/http"

	"github.com/gin-gonic/gin"
    "github.com/devguardio/oha/carrier"
    "github.com/devguardio/oha/db"
    "time"
    "encoding/json"
    "log"
)

// SystemDiscoveryGet - List available remote streams
func SystemDiscoveryGet(c *gin.Context) {
    user := CurrentUserApi(c);
    if user == nil {return}

    secrets, err := db.LoadDefaultSecretKit(user);
    if err != nil {
        c.JSON(http.StatusBadRequest, err);
    }

    var target = c.Query("target");
    if target == "" {
        c.JSON(http.StatusBadRequest, &Error{
            Code:       "MissingTarget",
            Message:    "missing target= query parameter",
        });
        return;
    }

    err = carrier.SystemDisco(c, secrets, target)
    if err != nil {
        c.JSON(http.StatusBadRequest, err);
    }
}

// SystemSensorsGet - Device Sensor Information
func SystemSensorsGet(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{})
}

// SystemSysinfoGet - Device System Information
func SystemSysinfoGet(c *gin.Context) {
    user := CurrentUserApi(c);
    if user == nil {return}

    secrets, err := db.LoadDefaultSecretKit(user);
    if err != nil {
        c.JSON(http.StatusBadRequest, err);
    }

    var target = c.Query("target");
    if target == "" {
        c.JSON(http.StatusBadRequest, &Error{
            Code:       "MissingTarget",
            Message:    "missing target= query parameter",
        });
        return;
    }

    err = carrier.SystemSysinfo(c, secrets, target)
    if err != nil {
        c.JSON(http.StatusBadRequest, err);
    }
}


func RawPost(c *gin.Context) {
    user := CurrentUserApi(c);
    if user == nil {return}

    secrets, err := db.LoadDefaultSecretKit(user);
    if err != nil {
        c.JSON(http.StatusBadRequest, err);
    }




    bb := RawRequest{};
    if err := c.BindJSON(&bb); err != nil {
        c.JSON(http.StatusBadRequest, &Error{
            Code:       "json",
            Message:    err.Error(),
        });
        return;
    }

    var target = bb.Target;
    if target == "" {
        c.JSON(http.StatusBadRequest, &Error{
            Code:       "MissingTarget",
            Message:    "missing target parameter",
        });
        return;
    }

    var path = bb.Path;
    if path == "" {
        c.JSON(http.StatusBadRequest, &Error{
            Code:       "MissingPath",
            Message:    "missing path parameter",
        });
        return;
    }

    headers := make(map[string][]string);

    for k, v := range bb.Headers {
        if vv, ok := v.(string); ok {
            headers[k] = append(headers[k], vv)
        }
    }

    err = carrier.Direct(c, carrier.DirectOpt{
        Headers:    headers,
        SecretKit:  *secrets,
        Target:     target,
        Path:       path,
        Cancel:     c.Done(),
        OnMessage:  func(msg []byte) {

            var dr = carrier.StreamMessage{
                Identity:   target,
                Path:       path,
                Time:       time.Now(),
                Data:       msg,
            };

            j, err2 := json.Marshal(dr)
            if err2 != nil {
                log.Printf("%v\n", err2);
                return;
            }
            c.Writer.Write(j);
        },
    });
    if err != nil {
        c.JSON(http.StatusBadRequest, err);
    }
}
