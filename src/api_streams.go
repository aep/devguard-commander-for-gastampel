/*
 * Devguard Open Hardware API
 *
 * Although devguard does offer direct end to end encrypted connections, some users may prefer a third party to establish a connection for them, as it is done by data hungry cloud corporations.  The Open Hardware API can be called with any standard https client by passing an secretkit in the headers, and a devguard hosted webservice will establish a device connection on behalf of the user.  We still do not collect any data, however due to the nature of webservices, interception by third parties is possible and the OHA service comes with no waranty whatsoever. 
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package server

import (
	"net/http"
	"github.com/gin-gonic/gin"
    "net/url"
    "github.com/devguardio/oha/db"
)

// StreamsGet - List subscriptions
func StreamsGet(c *gin.Context) {
    user := CurrentUserApi(c);
    if user == nil {return}

	c.JSON(http.StatusOK, gin.H{})
}

// StreamsIdDelete - Delete subscription
func StreamsIdDelete(c *gin.Context) {
    user := CurrentUserApi(c);
    if user == nil {return}

    id := c.Param("id");
    if id == "" || id == "undefined" {
        c.JSON(http.StatusBadRequest, Error{
            Code:       "json",
            Message:    "id cannot be empty",
        });
        return;
    }

    var ii db.Stream;
    dbc := db.DB.
        Joins("left join conduits on conduits.id = streams.conduit_id").
        Where("conduits.user_id = ?",user.Id).
        Where("streams.id = ?",id).
        First(&ii)

    if dbc.Error != nil {
        c.JSON(http.StatusBadRequest, Error{
            Code:       "db",
            Message:    dbc.Error.Error(),
        });
        return
    }

    db.DB.Delete(&ii);



    var conduit = db.Conduit{Id:ii.ConduitId};
    dbc = db.DB.First(&conduit);
    if dbc.Error != nil {
        c.JSON(http.StatusBadRequest, Error{
            Code:       "db",
            Message:    dbc.Error.Error(),
        });
        return
    }


    if agent, ok := ConduitAgents.Get(conduit.Id.String()); ok {
        agent.(*ConnectedAgent).Hup <- true
    }

	c.JSON(http.StatusOK, gin.H{})
}

// StreamsIdPut - Change subscription
func StreamsIdPut(c *gin.Context) {
    user := CurrentUserApi(c);
    if user == nil {return}

	c.JSON(http.StatusOK, gin.H{})
}

// StreamsPost - Create a new subscription
func StreamsPost(c *gin.Context) {
    user := CurrentUserApi(c);
    if user == nil {return}

    var sr = SubscriptionRequest{};
    if err := c.BindJSON(&sr); err != nil {
        c.JSON(http.StatusBadRequest, Error{
            Code:       "json",
            Message:    err.Error(),
        });
        return
    }

    if sr.Restart < 1 {
        c.JSON(http.StatusBadRequest, Error{
            Code:       "json",
            Message:    "restart cannot be null",
        });
        return;
    }

    if sr.Path == "" {
        c.JSON(http.StatusBadRequest, Error{
            Code:       "json",
            Message:    "path cannot be empty",
        });
        return;
    }

    if sr.Webhook.Url == "" {
        c.JSON(http.StatusBadRequest, Error{
            Code:       "json",
            Message:    "webhook.url cannot be empty",
        });
        return;
    }

    urlstr, ok := sr.Webhook.Url.(string)
    if !ok {
        c.JSON(http.StatusBadRequest, Error{
            Code:       "json",
            Message:    "webhook.url must be a valid url",
        });
        return;
    }

    url, err := url.Parse(urlstr);
    if err != nil {
        c.JSON(http.StatusBadRequest, Error{
            Code:       "json",
            Message:    err.Error(),
        });
        return;
    }


    if !db.IsWebhookHostAllowed(user, url.Host) {
        c.JSON(http.StatusBadRequest, Error{
            Code:       "json",
            Message:    "host '" + url.Host + "' is not a verified host. Please contact support to verify for user id " + user.Id.String(),
        });
        return;
    }

    conduits, err := db.ListConduits(user);
    if err != nil {
        c.JSON(http.StatusBadRequest, Error{
            Code:       "db",
            Message:    err.Error(),
        });
        return;
    }

    nu := db.Stream {
        ConduitId:      conduits[0].Id,
        Path:           sr.Path,
        RestartDelay:   uint(sr.Restart),
        WebhookUrl:     urlstr,
        Identity:       sr.Identity,
    }
    dbc := db.DB.Create(&nu);
    if dbc.Error != nil {
        c.JSON(http.StatusBadRequest, Error{
            Code:       "db",
            Message:    dbc.Error.Error(),
        });
        return;
    }

    if agent, ok := ConduitAgents.Get(conduits[0].Id.String()); ok {
        agent.(*ConnectedAgent).Hup <- true
    }

	c.JSON(http.StatusOK, nu);
}
